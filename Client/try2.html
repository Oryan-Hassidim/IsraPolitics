<!DOCTYPE html>
<html lang="he" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>חיפוש תלת ממדי</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            overflow: hidden;
            height: 100vh;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }

        #search-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.15);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        #searchInput {
            width: 300px;
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            outline: none;
            text-align: center;
            direction: rtl;
        }

        #searchInput::placeholder {
            color: #666;
        }

        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
        }

        .layer-info {
            margin: 5px 0;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="search-panel">
            <input type="text" id="searchInput" placeholder="הכנס טקסט לחיפוש...">
        </div>

        <div id="info-panel">
            <div class="layer-info">שכבה קרובה (כחול): <span id="layer1-count">0</span></div>
            <div class="layer-info">שכבה אמצעית (ירוק): <span id="layer2-count">0</span></div>
            <div class="layer-info">שכבה רחוקה (אדום): <span id="layer3-count">0</span></div>
        </div>

        <div id="canvas-container"></div>
        <div class="tooltip" id="tooltip"></div>
    </div>

</body>

<script>
    // נתונים לדוגמה - 2000 אלמנטים
    const sampleData = [];
    const categories = [
        "מחשב", "נייד", "טלפון", "מקלדת", "עכבר", "מסך", "רמקול", "מדפסת", "סורק", "מצלמה",
        "טאבלט", "שעון", "אוזניות", "מטען", "כבל", "כונן", "זיכרון", "מעבד", "לוח", "ספק",
        "מאוורר", "נורה", "בית", "כרטיס", "נתב", "מתג", "מודם", "אנטנה", "קול", "DVD",
        "SSD", "זיכרון", "קורא", "רכזת", "USB", "עדשה", "חצובה", "תיק", "כיסוי", "מחזיק",
        "סוללה", "אלחוטי", "חירום", "פנס", "רדיו", "מעורר", "כביסה", "מייבש", "מקרר", "מיקרוגל",
        "טוסטר", "קומקום", "בלנדר", "מעבד", "קפה", "צידנית", "גריל", "מחבת", "סיר", "מערבל",
        "מאזני", "מד", "שואב", "מגהץ", "גנרטור", "מפזר", "שולחן", "כיסא", "מיטה", "ארון",
        "מנורה", "שטיח", "וילון", "כרית", "שמיכה", "מראה", "תמונה", "ספר", "מחברת", "עט",
        "עיפרון", "מחק", "סרגל", "מספריים", "דבק", "סרט", "נייר", "קופסה", "תיק", "ארנק",
        "משקפיים", "שעון", "טבעת", "שרשרת", "עגילים", "צמיד", "תכשיט", "בושם", "קרם", "שמפו"
    ];

    for (let i = 0; i < 10; i++) {
        const category = categories[Math.floor(Math.random() * categories.length)];
        const number = Math.floor(Math.random() * 999) + 1;
        sampleData.push(`${category} ${number}`);
    }

    // משתנים גלובליים
    let scene, camera, renderer, raycaster, mouse;
    let allObjects = [];
    let currentFilter = '';

    // קבוצות שכבות
    let layer1Group, layer2Group, layer3Group;

    // מונים
    let layer1Count = 0, layer2Count = 0, layer3Count = 0;

    function init() {
        // יצירת הסצנה
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a2a3a);

        // יצירת המצלמה
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 30);

        // יצירת הרנדרר
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // יצירת קבוצות השכבות
        layer1Group = new THREE.Group(); // שכבה קרובה
        layer2Group = new THREE.Group(); // שכבה אמצעית  
        layer3Group = new THREE.Group(); // שכבה רחוקה

        layer1Group.position.z = 10;
        layer2Group.position.z = 0;
        layer3Group.position.z = -10;

        scene.add(layer1Group);
        scene.add(layer2Group);
        scene.add(layer3Group);

        // יצירת תאורה
        const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // תאורה נוספת
        const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
        pointLight.position.set(0, 0, 20);
        scene.add(pointLight);

        // יצירת האובייקטים
        createObjects();

        // יצירת raycaster לאינטראקציה
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        // הוספת מאזיני אירועים
        setupEventListeners();

        // התחלת הרנדור
        animate();
    }

    function createObjects() {
        allObjects = [];

        sampleData.forEach((text, index) => {
            const obj = createCard(text, index);
            allObjects.push({
                mesh: obj,
                text: text,
                originalText: text
            });

            // הוספה ראשונית לסצנה
            scene.add(obj);
        });

        // הצבה ראשונית - כל האלמנטים בשכבה האמצעית
        distributeObjects();
    }

    function createCard(text, index) {
        // יצירת גיאומטריה לכרטיס
        const geometry = new THREE.PlaneGeometry(4, 2);

        // יצירת חומר חצי שקוף
        const material = new THREE.MeshLambertMaterial({
            color: 0x4a90e2,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });

        const card = new THREE.Mesh(geometry, material);

        // יצירת טקסט על הכרטיס - רזולוציה גבוהה
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 1024;  // רזולוציה גבוהה יותר
        canvas.height = 512;

        context.fillStyle = 'rgba(74, 144, 226, 0.8)';
        context.fillRect(0, 0, canvas.width, canvas.height);

        // מסגרת לבנה
        context.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        context.lineWidth = 8;
        context.strokeRect(0, 0, canvas.width, canvas.height);

        context.fillStyle = 'white';
        context.font = 'bold 64px Arial';  // פונט גדול יותר
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.shadowColor = 'rgba(0, 0, 0, 0.5)';
        context.shadowBlur = 8;
        context.fillText(text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.generateMipmaps = false;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        card.material = new THREE.MeshLambertMaterial({
            map: texture,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });

        // הוספת מאפייני ריחוף אקראיים
        card.userData = {
            text: text,
            index: index,
            floatSpeed: Math.random() * 0.02 + 0.005,
            floatOffset: Math.random() * Math.PI * 2,
            rotateSpeed: (Math.random() - 0.5) * 0.01
        };

        return card;
    }

    function distributeObjects() {
        layer1Count = 0;
        layer2Count = 0;
        layer3Count = 0;

        if (currentFilter === '') {
            // אם החיפוש ריק - כל האלמנטים בשכבה האמצעית
            allObjects.forEach((obj, index) => {
                animateToPosition(obj.mesh, index, layer2Group, 0x4a90e2); // כחול-ירוק
                layer2Count++;
            });
        } else {
            // סינון לפי החיפוש
            const filteredObjects = allObjects.filter(obj =>
                obj.text.includes(currentFilter)
            );
            const nonFilteredObjects = allObjects.filter(obj =>
                !obj.text.includes(currentFilter)
            );

            // אלמנטים שלא עוברים את החיפוש - שכבה שלישית (רחוקה)
            nonFilteredObjects.forEach((obj, index) => {
                animateToPosition(obj.mesh, index, layer3Group, 0xff4444); // אדום
                layer3Count++;
            });

            // אלמנטים שעוברים את החיפוש
            if (filteredObjects.length > 25) {
                // יותר מ-25 - שכבה שנייה
                filteredObjects.forEach((obj, index) => {
                    animateToPosition(obj.mesh, index, layer2Group, 0x44ff44); // ירוק
                    layer2Count++;
                });
            } else {
                // פחות מ-25 - שכבה ראשונה (קרובה)
                filteredObjects.forEach((obj, index) => {
                    animateToPosition(obj.mesh, index, layer1Group, 0x4444ff); // כחול
                    layer1Count++;
                });
            }
        }

        updateCounters();
    }

    function animateToPosition(mesh, index, targetGroup, color) {
        const cols = 15;  // יותר עמודות לכמות הגדולה
        const spacing = 5;

        const row = Math.floor(index / cols);
        const col = index % cols;

        // חישוב מרכוז - כמה אלמנטים יש בשורה האחרונה
        const totalItems = targetGroup === layer1Group ? layer1Count :
            targetGroup === layer2Group ? layer2Count : layer3Count;
        const lastRowItems = totalItems % cols;
        const isLastRow = Math.floor(index / cols) === Math.floor((totalItems - 1) / cols);

        let targetX, targetY;

        if (isLastRow && lastRowItems > 0) {
            // מרכוז השורה האחרונה
            const lastRowOffset = (cols - lastRowItems) / 2;
            targetX = (col - cols / 2 + lastRowOffset) * spacing;
        } else {
            targetX = (col - cols / 2) * spacing;
        }

        targetY = -(row - Math.floor(totalItems / cols) / 2) * spacing;

        // הסרה מהקבוצה הנוכחית
        if (mesh.parent && mesh.parent !== scene) {
            mesh.parent.remove(mesh);
        }

        // הוספה לקבוצה החדשה
        targetGroup.add(mesh);

        // עדכון צבע הכרטיס
        updateCardColor(mesh, color);

        // אנימציה לתוצאה הרצויה
        animateObject(mesh, {
            x: targetX,
            y: targetY,
            z: 0
        }, 1000);
    }

    function updateCardColor(mesh, color) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 1024;  // רזולוציה גבוהה
        canvas.height = 512;

        // רקע בהיר יותר
        context.fillStyle = `rgba(${(color >> 16) & 255}, ${(color >> 8) & 255}, ${color & 255}, 0.8)`;
        context.fillRect(0, 0, canvas.width, canvas.height);

        // מסגרת לבנה
        context.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        context.lineWidth = 8;
        context.strokeRect(0, 0, canvas.width, canvas.height);

        context.fillStyle = 'white';
        context.font = 'bold 64px Arial';  // פונט גדול יותר
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.shadowColor = 'rgba(0, 0, 0, 0.5)';
        context.shadowBlur = 8;
        context.fillText(mesh.userData.text, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        texture.generateMipmaps = false;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        mesh.material.map = texture;
        mesh.material.needsUpdate = true;
    }

    function animateObject(object, targetPosition, duration) {
        const startPosition = {
            x: object.position.x,
            y: object.position.y,
            z: object.position.z
        };

        // שמירת המיקום הבסיס לריחוף
        object.userData.basePosition = {
            x: targetPosition.x,
            y: targetPosition.y,
            z: targetPosition.z
        };

        const startTime = Date.now();

        function updateAnimation() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // פונקציית easing לאנימציה חלקה
            const easeProgress = 1 - Math.pow(1 - progress, 3);

            const currentX = startPosition.x + (targetPosition.x - startPosition.x) * easeProgress;
            const currentY = startPosition.y + (targetPosition.y - startPosition.y) * easeProgress;
            const currentZ = startPosition.z + (targetPosition.z - startPosition.z) * easeProgress;

            // עדכון המיקום הבסיסי (לפני הריחוף)
            object.userData.basePosition = {
                x: currentX,
                y: currentY,
                z: currentZ
            };

            if (progress < 1) {
                requestAnimationFrame(updateAnimation);
            }
        }

        updateAnimation();
    }

    function updateCounters() {
        document.getElementById('layer1-count').textContent = layer1Count;
        document.getElementById('layer2-count').textContent = layer2Count;
        document.getElementById('layer3-count').textContent = layer3Count;
    }

    function setupEventListeners() {
        // חיפוש
        const searchInput = document.getElementById('searchInput');
        searchInput.addEventListener('input', (e) => {
            currentFilter = e.target.value;
            distributeObjects();
        });

        // תנועת עכבר למעקב אחר אובייקטים
        renderer.domElement.addEventListener('mousemove', onMouseMove);

        // גלילה לזום
        renderer.domElement.addEventListener('wheel', onMouseWheel);

        // טיפול בשינוי גודל חלון
        window.addEventListener('resize', onWindowResize);

        // קליק לאינטראקציה
        renderer.domElement.addEventListener('click', onMouseClick);
    }

    function onMouseMove(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // בדיקת intersection
        raycaster.setFromCamera(mouse, camera);
        const allMeshes = [...layer1Group.children, ...layer2Group.children, ...layer3Group.children];
        const intersects = raycaster.intersectObjects(allMeshes);

        const tooltip = document.getElementById('tooltip');

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            tooltip.textContent = obj.userData.text;
            tooltip.style.left = event.clientX + 10 + 'px';
            tooltip.style.top = event.clientY - 30 + 'px';
            tooltip.style.display = 'block';

            // הדגשת האובייקט
            obj.material.opacity = 0.9;
        } else {
            tooltip.style.display = 'none';
            // החזרת שקיפות רגילה לכל האובייקטים
            allMeshes.forEach(mesh => {
                mesh.material.opacity = 0.7;
            });
        }
    }

    function onMouseWheel(event) {
        camera.position.z += event.deltaY * 0.01;
        camera.position.z = Math.max(5, Math.min(50, camera.position.z));
    }

    function onMouseClick(event) {
        raycaster.setFromCamera(mouse, camera);
        const allMeshes = [...layer1Group.children, ...layer2Group.children, ...layer3Group.children];
        const intersects = raycaster.intersectObjects(allMeshes);

        if (intersects.length > 0) {
            const obj = intersects[0].object;
            alert(`נבחר: ${obj.userData.text}`);
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        // אנימציית ריחוף לכל האלמנטים
        const time = Date.now() * 0.001;
        // allObjects.forEach(obj => {
        //     const mesh = obj.mesh;
        //     if (mesh.parent) {
        //         // ריחוף אנכי
        //         const baseY = mesh.position.y;
        //         mesh.position.y = Math.sin(time * mesh.userData.floatSpeed + mesh.userData.floatOffset) * 0.003;

        //         // סיבוב עדין
        //         mesh.rotation.z += Math.sin(time * mesh.userData.rotateSpeed * 0.000000001);

        //         // ריחוף קל באלכסון
        //         mesh.position.x += Math.sin(time * mesh.userData.floatSpeed * 0.7 + mesh.userData.floatOffset) * 0.02;
        //     }
        // });

        // אנימציה עדינה של המצלמה
        camera.position.x = Math.sin(Date.now() * 0.0001) * 2;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
    }

    // התחלת האפליקציה
    init();
</script>

</html>