using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.FlowAnalysis;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml.Linq;

namespace CliArgsParse;

[Generator]
public sealed class CliGenerator : IIncrementalGenerator
{
    private const string _cliCommandAttributeFullName = "CliArgsAttributes.CliCommandAttribute";
    private const string _cliOptionAttributeFullName = "CliArgsAttributes.CliOptionAttribute";

    private static string ToKebabCasePreservingAcronyms(string input)
    {
        // מוסיף מקף לפני אות גדולה שלא חלק מראשי תיבות
        string withDashes = Regex.Replace(
            input,
            @"(?<=[a-z0-9])(?=[A-Z])", // תו קטן או מספר לפני אות גדולה
            "-"
        );

        // מחלק לפי מקפים
        var parts = withDashes.Split('-');

        // ממיר כל חלק ל־lowercase אלא אם הוא ראשי תיבות (כל האותיות גדולות)
        for (int i = 0; i < parts.Length; i++)
        {
            if (!Regex.IsMatch(parts[i], @"^[A-Z]{2,}$")) // אם זה לא ראשי תיבות
            {
                parts[i] = parts[i].ToLower();
            }
        }

        return string.Join("-", parts);
    }

    private static string Format(object? value, ITypeSymbol type)
    {
        if (value is null) return "null";
        return type.SpecialType switch
        {
            SpecialType.System_String => SymbolDisplay.FormatLiteral((value as string)!, true),
            SpecialType.System_Char => SymbolDisplay.FormatLiteral((char)value, true),
            _ => SymbolDisplay.FormatPrimitive(value, false, false)
        };
    }

    private static string FormatString(string? value)
    {
        if (value is null)
            return "null";
        return SymbolDisplay.FormatLiteral(value, true);
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var methodDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) => (MethodDeclarationSyntax)ctx.Node)
            ;

        var methodsWithCompilation = methodDeclarations
            .Combine(context.CompilationProvider)
            .Select((tuple, _) =>
            {
                var (methodSyntax, compilation) = tuple;
                var semanticModel = compilation.GetSemanticModel(methodSyntax.SyntaxTree);
                var symbol = semanticModel.GetDeclaredSymbol(methodSyntax);
                if (symbol != null && symbol.GetAttributes().Any(attr =>
                    attr.AttributeClass?.ToDisplayString() == _cliCommandAttributeFullName
                    ))
                {
                    return methodSyntax;
                }
                return null;
            })
            .Where(methodSyntax => methodSyntax != null)
            .Collect()
            .Combine(context.CompilationProvider)
            .Select((tuple, _) =>
            {
                var (methods, compilation) = tuple;
                var sources = new List<(string, string)>();

                var sb = new StringBuilder();
                sb.Append($$"""
// <auto-generated />
// This file was auto-generated by {{nameof(CliGenerator)}}.
                
using System.CommandLine;
using System.CommandLine.Invocation;
              
namespace GeneratedCli;
public static class CliEntry
{
    public static RootCommand Build()
    {
        var root = new RootCommand();

""");

                foreach (var method in methods)
                {
                    if (method is null) continue;
                    var semanticModel = compilation.GetSemanticModel(method.SyntaxTree);
                    var symbol = semanticModel.GetDeclaredSymbol(method) as IMethodSymbol;
                    if (symbol is null) continue;

                    var namespaceName = symbol.ContainingNamespace.ToDisplayString();
                    var attr = symbol.GetAttributes()
                        .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == _cliCommandAttributeFullName);
                    var propertyName = attr?.ConstructorArguments.FirstOrDefault().Value as string;
                    var className = symbol.ContainingType.Name;
                    var methodName = symbol.Name;
                    var commandName = string.IsNullOrEmpty(propertyName) ? ToKebabCasePreservingAcronyms(methodName) : propertyName;
                    var parameters = symbol.Parameters;
                    var commentXML = symbol.GetDocumentationCommentXml();
                    // <member name="M:CliArgs.MyClass.Greet(System.String)">
                    //     <summary>
                    //         Greet a person by name.
                    //     </summary>
                    //     <param name="name">the name of the person to greet</param>
                    // </member>
                    // convert XML to C# object
                    var comment = XDocument.Parse(string.IsNullOrEmpty(commentXML) ? "<member/>" : commentXML);

                    sb.AppendLine($$"""
        {
            // Method: {{namespaceName}}.{{className}}.{{methodName}}
            // File: {{method.SyntaxTree.FilePath}}:{{method.SyntaxTree.GetLineSpan(method.Span).StartLinePosition.Line + 1}}
            var cmd = new Command("{{commandName}}", {{FormatString(comment.Element("member")?.Element("summary")?.Value?.Trim() ?? null)}});

""");

                    foreach (var param in parameters)
                    {
                        if (param.HasExplicitDefaultValue)
                        {
                            var aliases = param.GetAttributes()
                                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == _cliOptionAttributeFullName)
                                ?.NamedArguments.FirstOrDefault(kv => kv.Key == "Aliases").Value.Values
                                .Cast<TypedConstant>().Select(c => ", " + c.ToCSharpString());
                            var aliasesString = aliases != null && aliases.Any() ? string.Join("", aliases) : "";

                            sb.Append($$"""
            var opt_{{param.Name}} = new Option<{{param.Type}}>("--{{ToKebabCasePreservingAcronyms(param.Name)}}"{{aliasesString}}) { 
                DefaultValueFactory = _ => {{Format(param.ExplicitDefaultValue, param.Type)}},
                Description = {{FormatString(comment.Element("member")?.Elements("param").FirstOrDefault(p => p.Attribute("name").Value == param.Name)?.Value?.Trim() ?? null)}},
            };
            cmd.Options.Add(opt_{{param.Name}});

""");
                        }
                        else
                        {
                            sb.Append($$"""
            var arg_{{param.Name}} = new Argument<{{param.Type}}>("{{ToKebabCasePreservingAcronyms(param.Name)}}") { 
                Description = {{FormatString(comment.Element("member")?.Elements("param").FirstOrDefault(p => p.Attribute("name").Value == param.Name)?.Value?.Trim() ?? null)}},
            };
            cmd.Arguments.Add(arg_{{param.Name}});

""");
                        }
                    }

                    sb.Append($$"""
            cmd.SetAction(pr => {{namespaceName}}.{{className}}.{{methodName}}(
                {{string.Join(",\n                    ",
                    parameters.Select(p => $"pr.GetValue({(p.HasExplicitDefaultValue ? "opt" : "arg")}_{p.Name})"))}}
                )
            );
            root.Subcommands.Add(cmd);
        }

""");
                }
                sb.Append("""
        return root;
    }
}

""");

                sources.Add(($"GeneratedCli.g.cs", sb.ToString()));

                return sources;
            });

        context.RegisterSourceOutput(methodsWithCompilation, (spc, sources) =>
        {
            foreach (var (hintName, source) in sources)
            {
                spc.AddSource(hintName, source);
            }
        });
    }
}

